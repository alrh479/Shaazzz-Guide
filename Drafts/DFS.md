پیش نیاز این مبحث تمامی فصل اول و دوم کتاب گراف شاززز است که میتوانید از [اینجا](https://gtoi.shaazzz.ir/) پیدا کنید.

## مسئله 
یک درخت به عنوان ورودی داده میشود. میخواهیم یک یال جدید به این درخت اضافه کنیم به طوری که تعداد مسیر های ساده متمایز بیشینه باشد. تعداد بیشینه بعد اضافه کردن یک یال را خروجی دهید. این سوال را میتوانید از [اینجا](https://codeforces.com/problemset/problem/1179/D) حل کنید.



## راه حل 
### $O(N^3)$
اول باید دید اضافه کردن یک یال دلخواه به درخت چه بلایی بر سر تعداد مسیر های خواسته شده میاورد. هر یالی که اضافه شود دقیقا یک دور می سازد. حال یال ها این دور را جدا کنید و یک جنگل داریم. هر دو راس درون یک درخت از این جنگل دقیقا یک مسیر دارند و هر دو راس از دو درخت جدا دقیقا ۲ مسیر دارند چون می توانند دوری که جدا کردیم را به دو روش طی کنند. پس اکنون می توانیم سوال را با فیکس کردن دو سر یال در $O(N ^ 2)$ سپس شمردن تعداد مسیر ها در $O(N)$ حل کنیم.

### $O(N ^ 2)$
وقتی یک یال اضافه می شود در واقع بین هر دو راس ۲ مسیر متمایز وجود دارد به جز راس هایی که وقتی دور را حذف میکنیم در مولفه یکسانی می افتند. پس اگر فرض کنیم $k$ مولفه همبندی با سایز $S_1, S_2, \dots, S_k$ می شود آنگاه جواب برابر است با:
$$2 \cdot \binom{N}{2} - \sum \limits_{i=1}^k \binom{S_i}{2}$$
چون
$2 \cdot \binom{N}{2}$ عدد ثابت است آنگاه کافی است مقدار دیگر را کمینه کنیم. 
میتوان دید که اگر یکی از رئوس این یال جدید برگ نباشد این یال بهینه نیست چون اگر از یک راس درخت را ریشه دار کنیم و راس با ارتفاع بیشتر را بگیریم چون آن راس برگ نیست میتوان آن را پایین تر برد و مقدار بالا کمتر می شود و اثبات را به خواننده واگذار می کنیم. در ادامه فرض کنید درخت از راس  اول ریشه دار شده است. حال تعریف می کنیم $dp_v$ برابر است با کمترین مقدار $\sum \limits_{i=1}^k \binom{S_i}{2}$ اگر از راس $v$ شروع کنیم و به یک برگ در زیردرخت آن برویم. در ابتدا فرض کنید میخواهید $dp$ را بدست بیاورید.

برای محاسبه $dp_v$ میتوان فرمول زیر را نوشت:
$$dp_v = \min_{u \text{ is child of } v} dp_u + \binom{Sub_v - Sub_u}{2}$$
که $Sub_u$ تعداد رئوس زیردرخت راس $u$ را نشان می دهد. اثبات این نیز ساده است و آن را به شما واگذار میکنیم.

حال بیاید یک سر یال جدید را فیکس کنید و درخت را از آن راس ریشه دار کنید و $DFS$ بزنید. می توان دید اگر درخت را از راس $v$ ریشه دار کنید جواب برابر با $dp_v$ است. پس چون محاسبه هر بار $dp$ به ازای هر راس ریشه $O(N)$ زمان می برد و $O(N)$ ریشه داریم در نهایت راه با زمان $O(N^2)$ داریم. 

### $O(N \sqrt{N})$
فرض کنید یال بین دو راس $u$, $v$ گذاشتیم آنگاه میخواهیم این حالت را به ازای مرتفع ترین جد مشترک آن ها حساب کنیم یعنی وقتی در راس $L$ هستیم که بلندترین جد مشترک آن دو است آن را محاسبه کنیم. میتوان دید که 
وقتی در راس $L$ هستیم و هر دو $u$ و $v$ با $L$ متفاوت هستند و $L$ بلندترین جد مشترک آن دو است پس آن دو راس در زیردرخت دو بچه متفاوت از راس $L$ قرار دارند همچنین میتوان نتیجه گرفت باید مسیری که $dp$ آن دو راس میدهد را طی کنیم تا مقدار کمینه ای داشته باشیم. حال با فیکس کردن آن دو بچه متفاوت از راس $L$ به فرمول زیر میرسیم. توجه کنید حالتی که یکی از $u$ و $v$ خود $L$ باشد را باید حساب کنیم که حالت خاصی از فرمول زیر است و به شما واگذار میکنیم. 
$$ans_L = \min_{u < w \text{ are childeren of } v} dp_u + dp_w + \binom{N - Sub_u - Sub_w}{2}$$
محاسبه هر $ans_i$ از لحاظ زمانی $O(deg_v^2)$ زمان می برد که از نظر زمانی همان $O(N^2)$ است. می توان دید که اگر ۳ عدد با $Sub_v$ برابر داشته باشیم می توان بزرگترین $dp$ دربین آن ها را حذف کرد و همچنان جواب تغییر نمی کند. پس از هر سایز زیردرخت متمایز حداکثر ۲ تا داریم. حال میتوان ثابت کرد از لحاظ زمانی این الگوریتم $O(N \sqrt {N})$ است و البته اینکه آیا این الگوریتم از $\Omega(N sqrt{N})$  باشد بعید به نظر می رسد و می توانید اطلاعات بیشتر را در [اینجا](https://codeforces.com/blog/entry/67891?#comment-521451) ببینید.

میدانیم
بیشینه تعداد اعداد متمایز وقتی جمع آن ها $S$ شود از 
$O(\sqrt{S})$
است.
در این صورت ما به ازای هر راس $v$ در الگوریتم حداکثر $O(N)$ زمان می دهیم چون حداکثر $O(\sqrt{N})$ بچه با زیردرخت متمایز دارد و هر دوتایی را با هم چک میکنیم. از طرفی چون هر دو بچه با هم چک می شوند حداکثر $O(deg_v^2)$ زمان می دهیم پس در کل باید مقدار زیر را حساب کنیم

$$ \sum \limits_{v=1}^N \min(deg_v^2, N) $$

میتوان دید بیشینه عبارت بالا زمانی محقق می شود که $deg_v = \sqrt{N}$ برقرار باشد و در این صورت جمع بالا برابر با خواسته ما می شود. 

پیاده سازی سوال را می توانید از [اینحا](https://codeforces.com/contest/1179/submission/232388194) ببینید. 
دراین کد برای اینکه حالتی که از راس $L$ به زیر درخت آن یال اضافه شود ایجاد نشود درخت از یک راس غیر برگ ریشه دار شده و در این حالت میتوان ثابت کرد که لازم نیست وقتی از راس $L$ به زیردرخت یال اضافه می شود را در مجموعه جواب حساب کرد. 