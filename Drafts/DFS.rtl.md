پیش نیاز این مبحث تمامی فصل اول و دوم کتاب گراف شاززز است که میتوانید از [اینجا](https://gtoi.shaazzz.ir/) پیدا کنید.
## مسئله
یک درخت داریم. میخواهیم یک یال به طور موقت با وزن $x$ به درخت اضافه کنیم به طوری که بیشینه فاصله از راس اول کمینه باشد. این مقدار کمینه را $f(x)$ در نظر میگیریم. به ازای هر $x$ از $1$ تا $N$ مقدار
$f(x)$ را خروجی دهید. این سوال را میتوانید از [اینجا](https://codeforces.com/problemset/problem/1632/E2) حل کنید.

## راه حل

می توان دید که $f(x)$ نانزولی است چون اگر یالی که به ازای
$x + 1$ 
در نظر میگیریم را وزنش را یکی کم کنیم فاصله هر راس در درخت به راس یک بیشتر نمی شود.
همچنین میتوان دید که 

$$ f(x + 1) - 1 \leq f(x) \leq f(x + 1)$$

طرف دیگر نیز به طریق مشابه می توان اثبات کرد. 

همچنین میتوان ثابت کرد همیشه یک سر یال اضافه شده روی راس 1 است. برای اثبات درخت را از راس 1 ریشه دار کنید و تمام رئوسی که از این یال در کوتاه ترین مسیر به ریشه استفاده میکنند را در نظر بگیرید و اگر یک راس چند کوتاه ترین مسیر داشت یکی را به دلخواه در نظر میگیریم. فرض کنید یالی که اضافه می شود بین راس $v$ و یک راس در زیردرخت آن مثل $u$ باشد. آنگاه تمام رئوسی که در نظر گرفتیم حتما از $u$ استفاده میکنند و به $v$ میروند. در این صورت میتوان دید هر چقدر $v$ را بالاتر ببریم جواب بیشتر نمی شود پس حالتی وجود دارد که راس ریشه یک سر یال باشد. اگر دو سر یال نیز بین یک راس و زیردرختش نبود به طریق مشابه می توان دید همه رئوسی که از یال استفاده میکنند زیردرخت یکی از دو سر یال هستند و در این صورت مثل حالت قبل میتوان بالاتر برد.

حال بلند ترین برگ را در نظر بگیرید و فرض کنید به ازای $f(x)$ جواب برابر $y$ شده است. در این صورت میتوان به طور حریصانه یال را بین راس 1 و راسی گذاشت که بالاترین جد بلند ترین برگ باشد و فاصله راس 1 تا بلندترین برگ دقیقا $y$ شود و بدیهی است این راس یکتا است. تعریف میکنیم $g(x)$ آن راسی باشد که یال بین 1 و  
$g(x)$ را با وزن $x$ کشیدیم. حال با توجه بالا میتوان گفت که $g(x)$ یا برابر با $g(x + 1)$ است یا پدر $g(x + 1)$ است و در صورتی برابر است که جواب یکی کمتر باشد و در صورتی پدر است که جواب دقیقا برابر باشد. پس اگر از بزرگترین $x$ شروع کنیم و به اول بیایم هر مرحله کافی است چک کنیم اگر برای راس کنونی یال وزن $x$ بین آن و ریشه رسم کنیم آیا بیشینه فاصله یکی کمتر می شود نسبت به دفعه قبل یا نه که این حالت نیز به سادگی قابل هست. هر مرحله یک مجموعه از رئوس نگه میداریم که نشان میدهد این رئوس از یالی که میکشیم استفاده میکنند و بقیه رئوس همان مسیر درون درخت را میروند. اگر جواب بخواهد یکی کمتر شود یعنی قبلا $z$ بوده و اکنون میخواهد 
$z - 1$
شود , رئوسی که ارتفاع درختی آن ها بیشتر $z$ است که حتما جزو همان مجموعه رئوس بودند چون جواب حداکثر $z$ است و برای آن ها اگر وزن یال یکی کم شود (نسبت به مرحله قبل آن) پس فاصلشان نیز یکی کم می شود پس در آن ها مشکلی نداریم. به ازای آن هایی که ارتفاع درختی کمتر $z$ است نیز مشکلی نداریم پس فقط باید ارتفاع دقیقا مساوی $z$ را چک کنیم که روی تمام آن ها دستی فور میزنیم و دستی چک میکنیم آیا در کوتاه ترین مسیرشان از یال جدید استفاده میکنند یا نه. اگر همه آن ها استفاده کنند می توان جواب را یکی کم کرد و گرنه نمی توان. اگر یکی در یک مرحله از یال جدید استفاده کند تا آخر از همان یال استفاده میکند پس هر راس که از یال استفاده کرد را پاک  میکنیم تا اردر خوب بماند. برای فهم بهتر به [کد](https://codeforces.com/contest/1632/submission/242562307) مراجعه کنید.


## مسئله 
یک درخت به عنوان ورودی داده میشود. میخواهیم یک یال جدید به این درخت اضافه کنیم به طوری که تعداد مسیر های ساده متمایز بیشینه باشد. تعداد بیشینه بعد اضافه کردن یک یال را خروجی دهید. این سوال را میتوانید از [اینجا](https://codeforces.com/problemset/problem/1179/D) حل کنید.



## راه حل 
### $O(N^3)$
اول باید دید اضافه کردن یک یال دلخواه به درخت چه بلایی بر سر تعداد مسیر های خواسته شده میاورد. هر یالی که اضافه شود دقیقا یک دور می سازد. حال یال ها این دور را جدا کنید و یک جنگل داریم. هر دو راس درون یک درخت از این جنگل دقیقا یک مسیر دارند و هر دو راس از دو درخت جدا دقیقا ۲ مسیر دارند چون می توانند دوری که جدا کردیم را به دو روش طی کنند. پس اکنون می توانیم سوال را با فیکس کردن دو سر یال در $O(N ^ 2)$ سپس شمردن تعداد مسیر ها در $O(N)$ حل کنیم.

### $O(N ^ 2)$
وقتی یک یال اضافه می شود در واقع بین هر دو راس ۲ مسیر متمایز وجود دارد به جز راس هایی که وقتی دور را حذف میکنیم در مولفه یکسانی می افتند. پس اگر فرض کنیم $k$ مولفه همبندی با سایز $S_1, S_2, \dots, S_k$ می شود آنگاه جواب برابر است با:
$$2 \cdot \binom{N}{2} - \sum \limits_{i=1}^k \binom{S_i}{2}$$
چون
$2 \cdot \binom{N}{2}$ عدد ثابت است آنگاه کافی است مقدار دیگر را کمینه کنیم. 
میتوان دید که اگر یکی از رئوس این یال جدید برگ نباشد این یال بهینه نیست چون اگر از یک راس درخت را ریشه دار کنیم و راس با ارتفاع بیشتر را بگیریم چون آن راس برگ نیست میتوان آن را پایین تر برد و مقدار بالا کمتر می شود و اثبات را به خواننده واگذار می کنیم. در ادامه فرض کنید درخت از راس  اول ریشه دار شده است. حال تعریف می کنیم $dp_v$ برابر است با کمترین مقدار $\sum \limits_{i=1}^k \binom{S_i}{2}$ اگر از راس $v$ شروع کنیم و به یک برگ در زیردرخت آن برویم. در ابتدا فرض کنید میخواهید $dp$ را بدست بیاورید.

برای محاسبه $dp_v$ میتوان فرمول زیر را نوشت:
$$dp_v = \min_{u \text{ is child of } v} dp_u + \binom{Sub_v - Sub_u}{2}$$
که $Sub_u$ تعداد رئوس زیردرخت راس $u$ را نشان می دهد. اثبات این نیز ساده است و آن را به شما واگذار میکنیم.

حال بیاید یک سر یال جدید را فیکس کنید و درخت را از آن راس ریشه دار کنید و $DFS$ بزنید. می توان دید اگر درخت را از راس $v$ ریشه دار کنید جواب برابر با $dp_v$ است. پس چون محاسبه هر بار $dp$ به ازای هر راس ریشه $O(N)$ زمان می برد و $O(N)$ ریشه داریم در نهایت راه با زمان $O(N^2)$ داریم. 

### $O(N \sqrt{N})$
فرض کنید یال بین دو راس $u$, $v$ گذاشتیم آنگاه میخواهیم این حالت را به ازای مرتفع ترین جد مشترک آن ها حساب کنیم یعنی وقتی در راس $L$ هستیم که بلندترین جد مشترک آن دو است آن را محاسبه کنیم. میتوان دید که 
وقتی در راس $L$ هستیم و هر دو $u$ و $v$ با $L$ متفاوت هستند و $L$ بلندترین جد مشترک آن دو است پس آن دو راس در زیردرخت دو بچه متفاوت از راس $L$ قرار دارند همچنین میتوان نتیجه گرفت باید مسیری که $dp$ آن دو راس میدهد را طی کنیم تا مقدار کمینه ای داشته باشیم. حال با فیکس کردن آن دو بچه متفاوت از راس $L$ به فرمول زیر میرسیم. توجه کنید حالتی که یکی از $u$ و $v$ خود $L$ باشد را باید حساب کنیم که حالت خاصی از فرمول زیر است و به شما واگذار میکنیم. 
$$ans_L = \min_{u < w \text{ are childeren of } v} dp_u + dp_w + \binom{N - Sub_u - Sub_w}{2}$$
محاسبه هر $ans_i$ از لحاظ زمانی $O(deg_v^2)$ زمان می برد که از نظر زمانی همان $O(N^2)$ است. می توان دید که اگر ۳ عدد با $Sub_v$ برابر داشته باشیم می توان بزرگترین $dp$ دربین آن ها را حذف کرد و همچنان جواب تغییر نمی کند. پس از هر سایز زیردرخت متمایز حداکثر ۲ تا داریم. حال میتوان ثابت کرد از لحاظ زمانی این الگوریتم $O(N \sqrt {N})$ است و البته اینکه آیا این الگوریتم از $\Omega(N sqrt{N})$  باشد بعید به نظر می رسد و می توانید اطلاعات بیشتر را در [اینجا](https://codeforces.com/blog/entry/67891?#comment-521451) ببینید.

میدانیم
بیشینه تعداد اعداد متمایز وقتی جمع آن ها $S$ شود از 
$O(\sqrt{S})$
است.
در این صورت ما به ازای هر راس $v$ در الگوریتم حداکثر $O(N)$ زمان می دهیم چون حداکثر $O(\sqrt{N})$ بچه با زیردرخت متمایز دارد و هر دوتایی را با هم چک میکنیم. از طرفی چون هر دو بچه با هم چک می شوند حداکثر $O(deg_v^2)$ زمان می دهیم پس در کل باید مقدار زیر را حساب کنیم

$$ \sum \limits_{v=1}^N \min(deg_v^2, N) $$

میتوان دید بیشینه عبارت بالا زمانی محقق می شود که $deg_v = \sqrt{N}$ برقرار باشد و در این صورت جمع بالا برابر با خواسته ما می شود. 

پیاده سازی سوال را می توانید از [اینحا](https://codeforces.com/contest/1179/submission/232388194) ببینید. 
دراین کد برای اینکه حالتی که از راس $L$ به زیر درخت آن یال اضافه شود ایجاد نشود درخت از یک راس غیر برگ ریشه دار شده و در این حالت میتوان ثابت کرد که لازم نیست وقتی از راس $L$ به زیردرخت یال اضافه می شود را در مجموعه جواب حساب کرد. 
